{
  "hash": "1cbc0a1da3bcbccc8e15feb55a544d37",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Getting user input for running a script\"\ndate: 2025-06-17\ncategories:\n  - R\n  - Rscript\n  - optparse\nslug: \"getting-user-input\"\n---\n\n\n\n\nGet users choices both interactively and for CLI script runs.\n\n## Intro\n\nI recently started playing in my scripts with having\n[different configurations selected by a user](../2025-05-11_first-yaml-config/index.qmd).\nHere I'll cover off a few simple ways to get some user selection, in both R and\nPython.\n\n## Get a selection out of some preset options\n\nWe can use `interactive()` to check if a user is running the script from an R\nconsole.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchoices <- c(\"apple\", \"banana\", \"cherry\")\n\nif (interactive()) {\n  choice_num <- utils::menu(choices)\n}\n\nchoice <- choices[choice_num]\n```\n:::\n\n\n\n\nThe above code collects console input with a prompt like this:\n\n![The {utils} menu](utils_menu.png){fig-alt='Three options listed vertically,\nfollowed by a prompt Selection:'}\n\n## Command line input\n\nWe can run a script as a command line tool in the shell like\n`Rscript my_script.R`. We  can capture strings passed in this context using\n`commandArgs()`. Specify the `trailingOnly` argument to get only strings after\nthe script name.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!interactive()) {\n  user_args <- commandArgs(trailingOnly = TRUE)\n}\n```\n:::\n\n\n\n\n`user_args` will be a character vector like `c('cat', 'apple', 'tree')` if we\nrun this in the shell:\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R cat apple tree\n```\n:::\n\n\n\n\n\n## So what kind of things might we do with this?\n\nWell, configuration options are going to be specific per script.\nHow about adding some behaviour to respond to a name:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_cli_args <- function() {\n  if (!interactive()) {\n    user_args <- commandArgs(trailingOnly = TRUE)\n\n    print(paste0(\"Hello, \", user_args[1], \"!\"))\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Writing to my_script.R\"}\n# hacky file write\nsave(parse_cli_args, file = 'parse_cli_args.Rdata')\n\ncat(\n  'load(\"parse_cli_args.Rdata\")\n  parse_cli_args()',\n  file = 'my_script.R'\n)\n```\n:::\n\n\n\n\nIf we write this to our file and include a call to `parse_cli_args()`, we can do\nthis:\n\nasdf asdf as dfas df asdf asdf as df asdf as fas df\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R reader\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, reader!\"\n```\n\n\n:::\n:::\n\n\n\n\nA more general typical argument is\nan option like \"verbose\" and/or \"quiet\" for printing more or less output during\na script run.\nBy convention options have a long name following 2 hyphens and many\nhave a single character version following one hyphen.\nLet's piece a bit more of this together:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_cli_args <- function() {\n  user_args <- commandArgs(trailingOnly = TRUE)\n\n  # find the string following the name arg definition.\n  name_pos <- grep(\"-n|--name\", user_args) + 1\n\n  if (length(name_pos) == 1) {\n    name <- user_args[name_pos]\n    print(paste0(\"Hello, \", name, \"!\"))\n  }\n\n  # v OR verbose\n  if (any(grepl(\"-v|--verbose\", user_args))) {\n    print(\"Printing extra output\")\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Writing to my_script.R\"}\n# hacky file write\nsave(parse_cli_args, file = 'parse_cli_args.Rdata')\n\ncat(\n  'load(\"parse_cli_args.Rdata\")\n  parse_cli_args()',\n  file = 'my_script.R'\n)\n```\n:::\n\n\n\n\nWe can start to play with different options, and combinations of options\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R --name again\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, again!\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R --v\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Printing extra output\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R --name world --verbose\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello, world!\"\n[1] \"Printing extra output\"\n```\n\n\n:::\n:::\n\n\n\n\n## optparse\n\nNow if we want to be a bit more serious about this, there are more things to\nconsider and edge cases to handle. We'll want to return a list of options\nfor usage throughout the script and we'll want to  We might be better turning to\na dedicated package like\n[{optparse}](https://trevorldavis.com/R/optparse/dev/)[^py],\nwhich sets out a framework for defining options, defaults and collecting the\ncorrect return types.\n\n[^py]: Which is based on the Python library\n[optparse](https://docs.python.org/3/library/optparse.html). On the topic of\nPython, `import sys` and `sys.argv` gives the equivalent to R's `commandArgs()`\nwhen running scripts like `python my_script.py`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_cli_args <- function() {\n  parser <- optparse::OptionParser()\n\n  parser <- optparse::add_option(\n    parser,\n    c(\"-n\", \"--name\"),\n    action = \"store\",\n    type = \"character\",\n    default = NULL,\n    help=\"Someone to say hello to\"\n  )\n\n  parser <- optparse::add_option(\n    parser,\n    c(\"-v\", \"--verbose\"),\n    action = \"store_true\",\n    default = FALSE,\n    help=\"Print extra output\"\n  )\n\n  optparse::parse_args(parser)\n}\n```\n:::\n\n\n\n\nThis gives us the same behaviour as before\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Writing to my_script.R\"}\n# hacky file write\nsave(parse_cli_args, file = 'parse_cli_args.Rdata')\n\ncat(\n  'load(\"parse_cli_args.Rdata\")\n  parse_cli_args()',\n  file = 'my_script.R'\n)\n```\n:::\n\n\n\n\n\nThis captures the arguments in a list:\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R --name reader\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$help\n[1] FALSE\n\n$name\n[1] \"reader\"\n\n$verbose\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\nPlus some informative help information:\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript my_script.R --help\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\nUsage: my_script.R [options]\n\n\nOptions:\n\t-h, --help\n\t\tShow this help message and exit\n\n\t-n NAME, --name=NAME\n\t\tSomeone to say hello to\n\n\t-v, --verbose\n\t\tPrint extra output\n```\n\n\n:::\n:::\n\n\n\n\n\n## Offer both options\n\nQuickly matching our shell args in our interactive version:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_opts_interactively <- function() {\n  name <- readline(\"Please enter your name:\")\n\n  choice_num <- utils::menu(c(\"Yes\", \"No\"),\n                            title = \"Print extra output to the console?\")\n\n  verbose <- as.logical(choice_num - 1)\n\n  list(name = name, verbose = verbose)\n}\n```\n:::\n\n\n\n\nWe can then provide both ways depending on how the user executes the script:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_user_args <- function() {\n  if (interactive()) {\n    return(get_opts_interactively())\n  }\n\n  parse_cli_args()\n}\n```\n:::\n\n\n\n\nWe might pass the results on as argument to other functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmain <- function(choices) {\n  if(choices$verbose) {\n    print(\"Printing extra stuff again!\")\n  }\n\n  name <- choices$name\n  print(paste0(\"Goodbye, \", name, \"!\"))\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Writing to my_script.R\"}\n# hacky file write to my_script.R :)\nsave(get_opts_interactively,\n     parse_cli_args,\n     parse_user_args,\n     main,\n     file = 'parse_user_args.Rdata')\n\ncat(\n  'load(\"parse_user_args.Rdata\")\n  choices <- parse_user_args()\n  main(choices)',\n  file = 'my_script.R'\n)\n```\n:::\n\n\n\n\nStill works the same:\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\nRscript my_script.R --name reader --verbose\n```\n\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Printing extra stuff again!\"\n[1] \"Goodbye, reader!\"\n```\n\n\n:::\n:::\n\n\n\n\n\n## Further thoughts\n\nI'm looking forward to playing with this, I think it will be particularly useful\nin the case of selecting configs. Though I don't working with `Rscript` in a\nshell is a particularly common workflow for R, I enjoy it for a \"completed\"\npipeline, where I can get it to run without booting up an IDE.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}