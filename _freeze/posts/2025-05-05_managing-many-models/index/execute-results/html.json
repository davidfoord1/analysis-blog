{
  "hash": "27ba6ef818ed7803fa9c5532f789f1fe",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Learning to manage many models in R'\ndate: 2025-05-05\ncategories:\n  - R\n  - dplyr\n  - tidyr\n  - purrr\n  - broom\n  - lm\n---\n\n\n\nUsing list-columns to process vectors of complex objects.\n\n## A need for many models\n\nI was tasked with creating a Slope Index of Inequality (SII) on a health\nperformance measure for all of a group of organisations in England, to look at\ninequalities across deprivation quintiles[^imd]. This meant I was going to need\nto run an individual weighted least squares regression on each of the\norganisations for every rolling 12-month period over several years.\n\n[^imd]: \n[English indices of deprivation](https://www.gov.uk/government/collections/english-indices-of-deprivation)\n\nHaving only run a single `lm()` call at a time before it seemed like it might be\nquite complicated.  The `lm` object produced has some complexity to it, and I\nfelt like I was going to have to go for a clunky and difficult split-apply-bind\nprocess, where the functions to apply were:\n\n  1. To build the model.\n\n  2. To also in some way to unpack it sensibly, ready for collating all the\n  results.\n\n## Learning about the magic of list-columns\n\nFortunately, I found this was a challenge that had already been well\nconsidered. In my search for a solution I ran in to a couple of very helpful\ntalks from regular R stars presenting an excellent, and importantly, simple way\nof tackling this with list-columns.\n \n- [Hadley Wickham - Managing many models](https://www.youtube.com/watch?v=rz3_FDVt9eg)\n- [Jenny Bryan - Row-oriented workflows](https://posit.co/resources/videos/thinking-inside-the-box-you-can-do-that-inside-a-data-frame/)\n\nA `data.frame` typically consists of columns which are \"atomic\" vectors, the\nbasic building blocks from an R-user perspective, of sequences of `numeric`,\n`character` and `logical` values. What do we do if we want a vector of some more\ncomplex objects, like an `lm` object? That's where lists come in. A list is a\ngeneric vector that can hold any kind of object.[^nest]\n\n[^nest]: Including *lists*. A `list` is a recursive structure in that it can hold\nother lists. Many more complex types are essentially just list themselves, \nincluding `lm` objects - you can investigate using `typeof()` and compare\nto the results of `class()`.\n\n## Dummy data\n\nWe'll create some fake data to show the structure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(5678)\n\ndates <- seq(as.Date('2018-01-01'), \n             as.Date('2024-12-01'), \n             \"months\")\n\ndummy_data <- expand.grid(org = LETTERS,\n                          deprivation = 1:5,\n                          reporting_date = dates,\n                          stringsAsFactors = FALSE)\n\n# make up some numbers!\ndummy_data$performance <- rnorm(NROW(dummy_data), mean = 0.65, sd = 0.1)\n\n# how many rows and columns?\ndim(dummy_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10920     4\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dummy_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  org deprivation reporting_date performance\n1   A           1     2018-01-01   0.6205873\n2   B           1     2018-01-01   0.6256962\n3   C           1     2018-01-01   0.6292701\n4   D           1     2018-01-01   0.5554947\n5   E           1     2018-01-01   0.5425486\n6   F           1     2018-01-01   0.5067928\n```\n\n\n:::\n:::\n\n\n\n## A column of tables\n\nSo, let's create our first list-column; the values by deprivation put into a\ntable grouped by organisation and date, nested within our overall table. We \ncan get there with tidyverse staple packages\n[dplyr](https://cran.r-project.org/web/packages/dplyr/index.html) and\n[tidyr](https://cran.r-project.org/web/packages/tidyr/index.html). \n`tidyr::nest()` is the restructuring powerhouse here, neatly wrapping up the\ndata into individual tables based on specified grouping:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models <- dummy_data |>\n  dplyr::group_by(org, reporting_date) |> \n  tidyr::nest() \n\n# the default column-name output by `nest()` is `data`\nhead(dummy_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n# Groups:   org, reporting_date [6]\n  org   reporting_date data            \n  <chr> <date>         <list>          \n1 A     2018-01-01     <tibble [5 × 2]>\n2 B     2018-01-01     <tibble [5 × 2]>\n3 C     2018-01-01     <tibble [5 × 2]>\n4 D     2018-01-01     <tibble [5 × 2]>\n5 E     2018-01-01     <tibble [5 × 2]>\n6 F     2018-01-01     <tibble [5 × 2]>\n```\n\n\n:::\n:::\n\n\n\nAll our values are still there, grouped together in each row. Here's the\ndata for just the first row:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models$data[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n  deprivation performance\n        <int>       <dbl>\n1           1       0.621\n2           2       0.626\n3           3       0.630\n4           4       0.467\n5           5       0.550\n```\n\n\n:::\n:::\n\n\n\nWe start to see the power of this structure. I think of each cell in a\nspreadsheet containing a whole table itself. We can operate on the `data`\ncolumn almost as if it was any old vector, within a `dplyr::mutate()` call.\n\n## A column of *models*\n\nWe'll create our SII model function as a simple wrapper around `lm()`.[^sii] \n\n[^sii]: The real thing has slightly more to it. There are specific x-values so\nthat the gradient represents the gap from lowest to highest deprivation\nquintiles, as opposed to the increase in \"performance\" per 1 unit increase in\n\"deprivation\". A `weights` argument is supplied to `lm()` to adjust for\npopulation, where the volumes are in another column in each `data` column table.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_sii <- function(df) lm(performance ~ deprivation, data = df)\n```\n:::\n\n\n\nOk, list-columns are not *quite* like any other column. We do need to make sure\nwe're outputting back to a list for the list-column to work. This could be a\nfeature we write in our function, but more simply we can apply a function to\nevery row and get a list back using either `lapply()` or `purrr:map()`. With\nthat we can use a regular assignment or `dplyr::mutate()` call.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models <- dummy_models |>\n  dplyr::mutate(sii_model = purrr::map(data, model_sii))\n\nhead(dummy_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   org, reporting_date [6]\n  org   reporting_date data             sii_model\n  <chr> <date>         <list>           <list>   \n1 A     2018-01-01     <tibble [5 × 2]> <lm>     \n2 B     2018-01-01     <tibble [5 × 2]> <lm>     \n3 C     2018-01-01     <tibble [5 × 2]> <lm>     \n4 D     2018-01-01     <tibble [5 × 2]> <lm>     \n5 E     2018-01-01     <tibble [5 × 2]> <lm>     \n6 F     2018-01-01     <tibble [5 × 2]> <lm>     \n```\n\n\n:::\n:::\n\n\n\nWe can't see much of what's going on individually like this, but I think it's is\ngreat - a whole model object per row! That's 2184 models. Yes,\neach row has the full thing we can take a look itself:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# model in the first row:\nsummary(dummy_models$sii_model[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = performance ~ deprivation, data = df)\n\nResiduals:\n       1        2        3        4        5 \n-0.01835  0.01749  0.05145 -0.08199  0.03139 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)   \n(Intercept)  0.66903    0.06350  10.536  0.00183 **\ndeprivation -0.03010    0.01915  -1.572  0.21395   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06054 on 3 degrees of freedom\nMultiple R-squared:  0.4517,\tAdjusted R-squared:  0.269 \nF-statistic: 2.472 on 1 and 3 DF,  p-value: 0.214\n```\n\n\n:::\n:::\n\n\n\n## Getting the values back out\n\nAnother R-star David Robinson makes it easier to then start pulling out some of\nthe data from the model results with the\n[broom package](https://cran.r-project.org/web/packages/broom/index.html). \nWe can use `broom::tidy()` to get our third list-column, which contains the\nmodel coefficients of the gradient and intercept.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models <- dummy_models |>\n  dplyr::mutate(sii_coeffs = purrr::map(sii_model, broom::tidy)) \n\nhead(dummy_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 5\n# Groups:   org, reporting_date [6]\n  org   reporting_date data             sii_model sii_coeffs      \n  <chr> <date>         <list>           <list>    <list>          \n1 A     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n2 B     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n3 C     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n4 D     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n5 E     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n6 F     2018-01-01     <tibble [5 × 2]> <lm>      <tibble [2 × 5]>\n```\n\n\n:::\n:::\n\n\n\nSo each row has a table of model info; we can see it has the standard errors and\nt-statistics and p-values too:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first row coefficients\ndummy_models$sii_coeffs[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic p.value\n  <chr>          <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)   0.669     0.0635     10.5  0.00183\n2 deprivation  -0.0301    0.0191     -1.57 0.214  \n```\n\n\n:::\n:::\n\n\n\nFinally {tidyr} helps us get the specific values back up to the main table. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models <- dummy_models |>\n  tidyr::unnest(sii_coeffs)\n\nhead(dummy_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 9\n# Groups:   org, reporting_date [3]\n  org   reporting_date data     sii_model term      estimate std.error statistic\n  <chr> <date>         <list>   <list>    <chr>        <dbl>     <dbl>     <dbl>\n1 A     2018-01-01     <tibble> <lm>      (Interce…   0.669     0.0635    10.5  \n2 A     2018-01-01     <tibble> <lm>      deprivat…  -0.0301    0.0191    -1.57 \n3 B     2018-01-01     <tibble> <lm>      (Interce…   0.689     0.0541    12.7  \n4 B     2018-01-01     <tibble> <lm>      deprivat…  -0.0195    0.0163    -1.20 \n5 C     2018-01-01     <tibble> <lm>      (Interce…   0.724     0.121      5.97 \n6 C     2018-01-01     <tibble> <lm>      deprivat…  -0.0342    0.0366    -0.935\n# ℹ 1 more variable: p.value <dbl>\n```\n\n\n:::\n:::\n\n\n\nNeatening up the output a bit:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_models <- dummy_models |> \n  dplyr::filter(term == \"deprivation\") |> \n  dplyr::select(org,\n                reporting_date,\n                sii = estimate,\n                std_err = std.error)\n  \nhead(dummy_models) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   org, reporting_date [6]\n  org   reporting_date      sii std_err\n  <chr> <date>            <dbl>   <dbl>\n1 A     2018-01-01     -0.0301   0.0191\n2 B     2018-01-01     -0.0195   0.0163\n3 C     2018-01-01     -0.0342   0.0366\n4 D     2018-01-01      0.00463  0.0279\n5 E     2018-01-01      0.0259   0.0434\n6 F     2018-01-01      0.0594   0.0188\n```\n\n\n:::\n:::\n\n\n\n## All together now\n\nThe key steps again in one chain, a succinct set of steps that simplifies\nsomething that could be quite complex:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy_data |> \n  dplyr::group_by(org, reporting_date) |> \n  tidyr::nest() |> # create our data column\n  dplyr::mutate(\n    sii_model = purrr::map(data, model_sii),        # 1 apply the model\n    sii_coeffs = purrr::map(sii_model, broom::tidy) # 2 unpack it sensibly \n  ) |> \n  tidyr::unnest(sii_coeffs) |> \n  dplyr::ungroup() \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,368 × 9\n   org   reporting_date data     sii_model term     estimate std.error statistic\n   <chr> <date>         <list>   <list>    <chr>       <dbl>     <dbl>     <dbl>\n 1 A     2018-01-01     <tibble> <lm>      (Interc…  0.669      0.0635    10.5  \n 2 A     2018-01-01     <tibble> <lm>      depriva… -0.0301     0.0191    -1.57 \n 3 B     2018-01-01     <tibble> <lm>      (Interc…  0.689      0.0541    12.7  \n 4 B     2018-01-01     <tibble> <lm>      depriva… -0.0195     0.0163    -1.20 \n 5 C     2018-01-01     <tibble> <lm>      (Interc…  0.724      0.121      5.97 \n 6 C     2018-01-01     <tibble> <lm>      depriva… -0.0342     0.0366    -0.935\n 7 D     2018-01-01     <tibble> <lm>      (Interc…  0.618      0.0924     6.68 \n 8 D     2018-01-01     <tibble> <lm>      depriva…  0.00463    0.0279     0.166\n 9 E     2018-01-01     <tibble> <lm>      (Interc…  0.560      0.144      3.89 \n10 E     2018-01-01     <tibble> <lm>      depriva…  0.0259     0.0434     0.597\n# ℹ 4,358 more rows\n# ℹ 1 more variable: p.value <dbl>\n```\n\n\n:::\n:::\n\n\n\n## Further thoughts \n\nIt will probably be a good idea to check out the \n[parameters package](https://cran.r-project.org/web/packages/parameters/index.html)\nat some point, which provides further utilities for working with model results\nbeyond the scope of {broom}.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}